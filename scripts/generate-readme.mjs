#!/usr/bin/env node
import { promises as fs } from 'node:fs';
import path from 'node:path';

class ReadmeGenerator {
  constructor() {
    this.template = `# @depup/{{packageName}}

> Dependency-bumped version of {{originalPackage}}

This package is automatically generated by [DepUp](https://github.com/depup/npm) to provide up-to-date dependencies for {{originalPackage}}.

## ğŸ¯ What is DepUp?

DepUp automatically creates scoped clones of popular npm packages with their dependencies bumped to the latest versions. This ensures you get the latest security patches and features without waiting for the original maintainers to update their dependencies.

## ğŸ“¦ Package Information

- **Original Package**: [{{originalPackage}}](https://www.npmjs.com/package/{{originalPackage}})
- **DepUp Version**: {{version}}
- **Original Version**: {{originalVersion}}
- **Last Updated**: {{lastUpdated}}

## ğŸš€ Installation

\`\`\`bash
npm install @depup/{{packageName}}
\`\`\`

## ğŸ“Š Integrity Status

{{integrityTable}}

## ğŸ”„ Version History

{{versionHistory}}

## ğŸ¤ Contributing

Found an issue with this package? You can help improve it:

1. **Vote on package integrity**: Use the integrity meter above to report if this package works or has issues
2. **Submit feedback**: Include details about any problems you encounter
3. **Contribute to DepUp**: Help improve the automation that creates these packages

## ğŸ“„ License

This package inherits the license from the original package. See the original package's license for details.

---

*Generated by [DepUp](https://github.com/depup/npm) - Automated dependency bumping for npm packages*`;
  }

  async main() {
    const packageName = process.argv[2];

    if (!packageName) {
      console.error('Usage: node scripts/generate-readme.mjs <package-name>');
      process.exit(1);
    }

    try {
      await this.generateReadme(packageName);
      console.log(`âœ… Generated README for ${packageName}`);
    } catch (error) {
      console.error('Error generating README:', error.message);
      process.exit(1);
    }
  }

  async generateReadme(packageName) {
    const packageDir = path.join(process.cwd(), packageName);
    const integrityFile = path.join(packageDir, 'integrity.json');
    const votesFile = path.join(packageDir, 'votes.json');

    // Load integrity data
    let integrityData = {};
    try {
      const data = await fs.readFile(integrityFile);
      integrityData = JSON.parse(data);
    } catch {
      console.warn(`No integrity data found for ${packageName}`);
    }

    // Load votes data
    let votesData = {};
    try {
      const data = await fs.readFile(votesFile);
      votesData = JSON.parse(data);
    } catch {
      console.warn(`No votes data found for ${packageName}`);
    }

    // Get latest version info
    const versions = Object.keys(integrityData).sort();
    const latestVersion = versions.at(-1);

    if (!latestVersion) {
      throw new Error(`No version data found for ${packageName}`);
    }

    const latestRevision = Object.keys(integrityData[latestVersion])
      .sort()
      .pop();
    const latestData = integrityData[latestVersion][latestRevision];

    // Generate content
    const content = this.template
      .replaceAll('{{packageName}}', packageName)
      .replaceAll('{{originalPackage}}', packageName)
      .replaceAll('{{version}}', latestData?.version || 'unknown')
      .replaceAll('{{originalVersion}}', latestVersion)
      .replaceAll(
        '{{lastUpdated}}',
        latestData?.timestamp
          ? new Date(latestData.timestamp).toLocaleDateString()
          : 'unknown',
      )
      .replaceAll(
        '{{integrityTable}}',
        this.generateIntegrityTable(integrityData, votesData),
      )
      .replaceAll(
        '{{versionHistory}}',
        this.generateVersionHistory(integrityData, votesData),
      );

    // Write README
    const readmePath = path.join(packageDir, 'README.md');
    await fs.writeFile(readmePath, content);
  }

  generateIntegrityTable(integrityData, votesData) {
    if (Object.keys(integrityData).length === 0) {
      return 'No integrity data available yet.';
    }

    let table = '| Version | Revision | Status | Score | Votes |\n';
    table += '|---------|----------|--------|-------|-------|\n';

    for (const [version, versionData] of Object.entries(integrityData)) {
      for (const [revision, data] of Object.entries(versionData)) {
        const integrity = data.integrity || {};
        const score = integrity.score || 0;
        const totalVotes = integrity.totalVotes || 0;
        const status = this.getStatusEmoji(score);

        table += `| ${version} | ${revision} | ${status} | ${score}% | ${totalVotes} |\n`;
      }
    }

    return table;
  }

  generateVersionHistory(integrityData, votesData) {
    if (Object.keys(integrityData).length === 0) {
      return 'No version history available yet.';
    }

    let history = '';

    for (const [version, versionData] of Object.entries(integrityData)) {
      history += `\n### Version ${version}\n\n`;

      for (const [revision, data] of Object.entries(versionData)) {
        const integrity = data.integrity || {};
        const score = integrity.score || 0;
        const status = this.getStatusEmoji(score);

        history += `- **Revision ${revision}** (${data.version}) - ${status} ${score}% integrity\n`;

        if (integrity.lastUpdated) {
          history += `  - Last updated: ${new Date(integrity.lastUpdated).toLocaleDateString()}\n`;
        }
      }
    }

    return history;
  }

  getStatusEmoji(score) {
    if (score >= 80) return 'ğŸŸ¢ Excellent';
    if (score >= 60) return 'ğŸŸ¡ Good';
    if (score >= 40) return 'ğŸŸ  Fair';
    return 'ğŸ”´ Poor';
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const generator = new ReadmeGenerator();
  generator.main();
}
