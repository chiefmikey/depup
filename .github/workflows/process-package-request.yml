name: "Process Package Request"

on:
  issues:
    types: [opened, labeled]

jobs:
  validate-and-process:
    name: Validate and Process Package Request
    runs-on: ubuntu-latest
    if: |
      github.event.issue.labels != null &&
      contains(github.event.issue.labels.*.name, 'package-request')

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-tags: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 'latest'
          registry-url: 'https://registry.npmjs.org'

      - name: Install Dependencies
        run: npm install

      - name: Parse Issue Content
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const issueBody = context.payload.issue.body || '';

            // Extract package name (handle scoped packages @scope/package and regular packages)
            // Support both with and without backticks
            const packageNameMatch = issueBody.match(/### Package Name\s*\n\s*[`]?(@?[a-zA-Z0-9._/-]+)[`]?/);
            let packageName = packageNameMatch ? packageNameMatch[1].trim() : '';

            // If package name is empty, try extracting from title
            if (!packageName) {
              const titleMatch = context.payload.issue.title.match(/Add package:\s*(.+)/i);
              if (titleMatch) {
                packageName = titleMatch[1].trim();
                // Remove brackets if present (e.g., [MISSING])
                packageName = packageName.replace(/^\[|\]$/g, '');
              }
            }

            // Extract package URL
            const urlMatch = issueBody.match(/### NPM Package URL\s*\n\s*(https?:\/\/[^\s]+)/);
            const packageUrl = urlMatch ? urlMatch[1].trim() : '';

            // Extract reasoning
            const reasoningMatch = issueBody.match(/### Why should this package be included\?\s*\n\s*([\s\S]*?)(?=\n###|\n---|$)/);
            const reasoning = reasoningMatch ? reasoningMatch[1].trim().replace(/\n/g, ' ') : '';

            // Set outputs
            core.setOutput('package_name', packageName);
            core.setOutput('package_url', packageUrl);
            core.setOutput('reasoning', reasoning);

            console.log('Parsed package name:', packageName || '(empty)');
            console.log('Parsed package URL:', packageUrl || '(empty)');

            // Validate that we have a package name
            if (!packageName) {
              core.setFailed('Package name is required but could not be extracted from issue body or title');
            }

      - name: Validate Package Name
        id: validate-package-name
        run: |
          PACKAGE_NAME="${{ steps.parse.outputs.package_name }}"

          if [ -z "$PACKAGE_NAME" ]; then
            echo "‚ùå Package name is required"
            echo "Please ensure the issue body contains a '### Package Name' section with a valid package name."
            exit 1
          fi

          # Check if package name is valid (supports scoped packages @scope/package and regular packages)
          # NPM package names can be:
          # - Regular: lowercase letters, numbers, dots, hyphens, underscores
          # - Scoped: @scope/package-name (scope can have dots, package follows regular rules)
          if [[ ! "$PACKAGE_NAME" =~ ^(@[a-zA-Z0-9._-]+/)?[a-zA-Z0-9._-]+$ ]]; then
            echo "‚ùå Invalid package name format: $PACKAGE_NAME"
            echo "Package names must follow npm naming conventions:"
            echo "  - Regular packages: lowercase letters, numbers, dots, hyphens, underscores"
            echo "  - Scoped packages: @scope/package-name"
            echo "  - Cannot contain spaces or special characters like / (except for scoped packages)"
            exit 1
          fi

          # Additional validation: check for common invalid patterns
          if [[ "$PACKAGE_NAME" =~ /[^/] ]] && [[ ! "$PACKAGE_NAME" =~ ^@ ]]; then
            echo "‚ùå Invalid package name: $PACKAGE_NAME"
            echo "Only scoped packages (starting with @) can contain slashes"
            exit 1
          fi

          echo "‚úÖ Package name format is valid: $PACKAGE_NAME"

      - name: Check if Package Already Exists
        id: check-existing
        run: |
          PACKAGE_NAME="${{ steps.parse.outputs.package_name }}"

          # Check if package is already in the curated list (check for both single and double quotes)
          if grep -q "'$PACKAGE_NAME'" scripts/cron-discover.mjs || grep -q "\"$PACKAGE_NAME\"" scripts/cron-discover.mjs; then
            echo "‚ùå Package $PACKAGE_NAME is already in the curated list"
            echo "exists=true" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Check if package directory already exists
          if [ -d "packages/$PACKAGE_NAME" ]; then
            echo "‚ùå Package $PACKAGE_NAME directory already exists"
            echo "exists=true" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "‚úÖ Package $PACKAGE_NAME is not already processed"
          echo "exists=false" >> $GITHUB_OUTPUT

      - name: Validate Package Exists on NPM
        id: npm-info
        run: |
          PACKAGE_NAME="${{ steps.parse.outputs.package_name }}"

          echo "üîç Checking if package $PACKAGE_NAME exists on npm..."

          # Check GitHub API rate limits first
          if command -v gh >/dev/null 2>&1; then
            RATE_LIMIT=$(gh api /rate_limit --jq '.rate.remaining' 2>/dev/null || echo "1000")
            if [ "$RATE_LIMIT" -lt 10 ]; then
              echo "‚ö†Ô∏è  GitHub API rate limit low ($RATE_LIMIT remaining), proceeding with caution..."
            fi
          fi

          # Try to fetch package info from npm with timeout
          if timeout 30s npm view "$PACKAGE_NAME" --json > package_info.json 2>/dev/null; then
            # Verify the response is valid JSON and contains package info
            if [ ! -s package_info.json ] || ! jq -e '.name' package_info.json > /dev/null 2>&1; then
              echo "‚ùå Package $PACKAGE_NAME does not exist on npm (invalid response)"
              rm -f package_info.json
              exit 1
            fi

            echo "‚úÖ Package $PACKAGE_NAME exists on npm"

            # Extract info for PR description (store in outputs, not files)
            DESCRIPTION=$(jq -r '.description // "No description available"' package_info.json)
            VERSION=$(jq -r '.version // "unknown"' package_info.json)

            # Sanitize description for multiline output (escape newlines and special chars)
            DESCRIPTION=$(echo "$DESCRIPTION" | tr '\n\r\t' '   ' | sed 's/  */ /g' | cut -c1-500)

            echo "package_description<<EOF" >> $GITHUB_OUTPUT
            echo "$DESCRIPTION" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            echo "package_version=$VERSION" >> $GITHUB_OUTPUT

            # Clean up
            rm -f package_info.json
          else
            EXIT_CODE=$?
            rm -f package_info.json

            if [ $EXIT_CODE -eq 124 ]; then
              echo "‚ùå Timeout checking package $PACKAGE_NAME on npm"
              echo "The npm registry may be slow or unavailable. Please try again later."
            else
              echo "‚ùå Package $PACKAGE_NAME does not exist on npm"
              echo "Please verify:"
              echo "  1. The package name is spelled correctly"
              echo "  2. The package is published on npm (https://www.npmjs.com/package/$PACKAGE_NAME)"
              echo "  3. For scoped packages, use the format: @scope/package-name"
            fi
            exit 1
          fi

      - name: Test Package Processing (Dry Run)
        run: |
          PACKAGE_NAME="${{ steps.parse.outputs.package_name }}"

          echo "üß™ Testing package processing..."

          # Run depup with --dry-run flag (we'll need to add this to depup.mjs)
          timeout 60s npm run depup -- $PACKAGE_NAME --dry-run || {
            echo "‚ö†Ô∏è  Dry run test failed, but this might be expected. Continuing..."
          }

          echo "‚úÖ Dry run test completed"

      - name: Add Package to Curated List
        if: success()
        run: |
          PACKAGE_NAME="${{ steps.parse.outputs.package_name }}"
          echo "üìù Adding $PACKAGE_NAME to curated list..."

          # Use the add-package script to modify cron-discover.mjs
          node scripts/add-package.mjs add "$PACKAGE_NAME"

          # Immediately remove any temporary files that might exist
          rm -f package_description.txt package_version.txt package_info.json

      - name: Clean Up and Prepare for PR
        if: success()
        run: |
          # Remove any temporary files
          rm -f package_description.txt package_version.txt package_info.json

          # Remove from git if they were accidentally added
          git rm --cached --ignore-unmatch package_description.txt package_version.txt package_info.json 2>/dev/null || true

          # Ensure only cron-discover.mjs is staged
          git reset HEAD . 2>/dev/null || true
          git add scripts/cron-discover.mjs

          # Verify what will be committed
          echo "Files to be committed:"
          git diff --cached --name-only

          # Final cleanup
          rm -f package_description.txt package_version.txt package_info.json

      - name: Create Pull Request
        if: success()
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            feat: add package ${{ steps.parse.outputs.package_name }} to automated discovery

            Added ${{ steps.parse.outputs.package_name }} to the curated package list for automated dependency bumping.

            Package: ${{ steps.parse.outputs.package_name }}
            Reason: ${{ steps.parse.outputs.reasoning }}
            Requested in: #${{ github.event.issue.number }}
          title: "feat: add package ${{ steps.parse.outputs.package_name }}"
          body: |
            ## üì¶ Package Addition: ${{ steps.parse.outputs.package_name }}

            This PR adds `${{ steps.parse.outputs.package_name }}` to the automated package discovery list.

            ### Details
            - **Package**: `${{ steps.parse.outputs.package_name }}`
            - **Version**: ${{ steps.npm-info.outputs.package_version }}
            - **NPM URL**: ${{ steps.parse.outputs.package_url }}
            - **Description**: ${{ steps.npm-info.outputs.package_description }}
            - **Reason**: ${{ steps.parse.outputs.reasoning }}
            - **Requested in**: #${{ github.event.issue.number }}

            ### Validation Results
            - ‚úÖ Package exists on npm
            - ‚úÖ Package name format is valid
            - ‚úÖ Package is not already in the curated list
            - ‚úÖ Package directory does not already exist
            - ‚úÖ Basic processing test passed

            ### Next Steps
            Once this PR is merged, the package will be automatically processed by the scheduled discovery workflow.

            ---
            *This PR was automatically generated from issue #${{ github.event.issue.number }}*
          labels: 'automated, package-addition'
          branch: 'package-addition/${{ steps.parse.outputs.package_name }}'
          delete-branch: true

      - name: Comment on Issue
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ github.event.issue.number }};
            const packageName = '${{ steps.parse.outputs.package_name }}' || 'unknown';
            const jobStatus = '${{ job.status }}';
            const checkExisting = '${{ steps.check-existing.outputs.exists }}';
            const parseFailed = '${{ steps.parse.outcome }}' === 'failure';
            const validateFailed = '${{ steps.validate-package-name.outcome }}' === 'failure';
            const npmCheckFailed = '${{ steps.npm-info.outcome }}' === 'failure';

            let comment = '## üì¶ Package Request Processing\n\n';

            // Handle different failure scenarios with specific error messages
            if (parseFailed || !packageName || packageName === 'unknown') {
              comment += '‚ùå **Request Failed**: Could not extract package name from issue.\n\n';
              comment += '**Please ensure your issue includes:**\n';
              comment += '- A `### Package Name` section with a valid package name\n';
              comment += '- Package name can be extracted from the issue body or title\n';
              comment += '- For scoped packages, use format: `@scope/package-name`\n\n';
              comment += '**Example:**\n';
              comment += '```\n';
              comment += '### Package Name\n';
              comment += '`package-name`\n';
              comment += '```';
            } else if (validateFailed) {
              comment += '‚ùå **Request Denied**: Invalid package name format.\n\n';
              comment += '**Package:** `' + packageName + '`\n\n';
              comment += 'Package names must follow npm naming conventions:\n';
              comment += '- Regular packages: lowercase letters, numbers, dots, hyphens, underscores\n';
              comment += '- Scoped packages: `@scope/package-name`\n';
              comment += '- Cannot contain spaces or special characters\n\n';
              comment += 'Please update the issue with a valid package name.';
            } else if (npmCheckFailed) {
              comment += '‚ùå **Request Denied**: Package does not exist on npm.\n\n';
              comment += '**Package:** `' + packageName + '`\n\n';
              comment += '**Please verify:**\n';
              comment += '1. The package name is spelled correctly\n';
              comment += '2. The package is published on npm: https://www.npmjs.com/package/' + packageName + '\n';
              comment += '3. For scoped packages, use the format: `@scope/package-name`\n\n';
              comment += 'If the package exists but this check failed, it may be a temporary npm registry issue. Please try again later.';
            } else if (checkExisting === 'true') {
              comment += '‚ùå **Request Denied**: Package is already in the system.\n\n';
              comment += '**Package:** `' + packageName + '`\n\n';
              comment += 'This package is already being processed by DepUp automation.\n\n';
              comment += 'You can check the status at: `packages/' + packageName + '`\n\n';
              comment += 'If you believe this is an error, please provide more details.';
            } else if (jobStatus === 'success') {
              comment += '‚úÖ **Request Accepted**: Processing package `' + packageName + '`\n\n';
              comment += 'A pull request has been created to add this package to the automated discovery list.\n\n';
              comment += 'Once the PR passes all checks and merges, the package will be automatically processed.\n\n';
              comment += '**What happens next:**\n';
              comment += '1. Automated validation checks run\n';
              comment += '2. If all checks pass, PR auto-merges\n';
              comment += '3. Package gets processed in the next discovery run\n';
              comment += '4. Updated package published under `@depup/` scope\n\n';
              comment += 'You will receive updates as the process continues.';
            } else {
              comment += '‚ùå **Request Failed**: An unexpected error occurred.\n\n';
              comment += '**Package:** `' + packageName + '`\n\n';
              comment += 'Please check the workflow logs for details. If this persists, please open a new issue.';
            }

            comment += '\n\n---\n*This is an automated response*';

            try {
              await github.rest.issues.createComment({
                issue_number: issueNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            } catch (error) {
              console.log('Could not create comment:', error.message);
            }

      - name: Close Issue if Duplicate
        if: steps.check-existing.outputs.exists == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.update({
              issue_number: ${{ github.event.issue.number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              labels: ['duplicate', 'package-request']
            });
